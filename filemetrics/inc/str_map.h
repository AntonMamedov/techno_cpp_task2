#pragma once
#include <stdint.h>
#include "str.h"

//Макросы - индикаторы
#define INSERTED 0 //Элемент был вставлен
#define FOUND 1    //Элемент был найден

//Структура, инкапсулирующая в себе ключ и значение, содержащиеся в ноде дерева
/*
 * Так сделано, потому что в одном месте программы была необходима возможность
 * возврата из функции указателя на ключ
 */
typedef struct{
    String key;   //Ключ
    uint64_t val; //Значение
}StrMapData;

//Структура, являющаяся узлом дерева
typedef struct StrMapNode{
    struct StrMapNode *left;   //Указатель на левого потомка
    struct StrMapNode *right;  //Указатель на правого потомка
    StrMapData data;           //Данные
}StrMapNode;

//Структура, инкопсулирующая в себе корень дерева
typedef struct{
    StrMapNode* root;  //Корень дерева
    size_t size;       //Размер дерева
}StrMap;

int map_init(StrMap *map);
StrMapData* map_insert_or_search(char* key, StrMap* map, int* flag);
int map_release(StrMap* map);
int map_pre_order(StrMap* map, void(*work)(StrMapData* data, void* data_for_work), void* data_for_work);

/*
 * map_init - инициализирует дерево, в случае успеха возвращает 0, иначе -1
 * map_insert_or_search - вставляет в дерево элемент по ключу и возвращает указатель на данные созданного узла,
 * в случае, если такой ключ уже существует, просто возвращает указатель на данные
 * 1 аргумент - ключ, 2 аргумент - дерево, 3 аргумент - индикатор, указывающий на то, был элемент вставлен или найден
 * В случае неудачи возвращает NULL
 * map_release - рекурсивно очищает каждый узел дерева, в случае неудачи возвращает -1, в случае удачи - 0
 * map_pre_order - рекурсивно обходит каждый узел дерева и вызывает функцию переданную в качестве второго аргумента
 * 1 аргумент - дерево, 2 аргумент - функция, выполняющая действия на узле, 3 аргумент - данные для функции 2 аругмента
 * в случае удачи возвращет 0, в случа неудачи -1;
 */